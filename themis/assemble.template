
// IS THE INDEXING IN VALS CORRECT FOR VECTOR-VALUED?
{%macro SETVALS() -%}
{% for ci in range(space1.ncomp) %}
compoffset = 0
for (lx=0;lx<{{ space1.nbasis_x[ci] }};lx++) {
for (ly=0;ly<{{ space1.nbasis_y[ci] }};ly++) {
for (lz=0;lz<{{ space1.nbasis_z[ci] }};lz++) {
for (d=0;d<{{ space1.ndofs }};d++){
const PetscInt ii = i + cell1x_{{ci}}[lx];
const PetscInt jj = j + cell1y_{{ci}}[ly];
const PetscInt kk = k + cell1z_{{ci}}[lz];
{% if ndim == 1 %}
data_formvec[ii][idx1_{{ ci }}[lx][ly][lz][d]] += vals [compoffset + lz + {{  space1.nbasis_z[ci]  }} * (ly + {{ space1.nbasis_y[ci]  }} * lx)][d];
{% endif %}
{% if ndim == 2 %}
data_formvec[jj][ii][idx1_{{ ci }}[lx][ly][lz][d]] += vals [compoffset + lz + {{  space1.nbasis_z[ci]  }} * (ly + {{ space1.nbasis_y[ci]  }} * lx)][d];
{% endif %}
{% if ndim == 3 %}
data_formvec[kk][jj][ji][idx1_{{ ci }}[lx][ly][lz][d]] += vals [compoffset + lz + {{  space1.nbasis_z[ci]  }} * (ly + {{ space1.nbasis_y[ci]  }} * lx)][d];
{% endif %}
}}}}
  compoffset = compoffset + {{ nbasis1[ci] }};
  {% endfor %}
{% endmacro %}

#include <petsc.h>
#include "math.h"
#include <stdio.h>

//Actual kernel snippet
{{ kernelstr }}

{% if formdim == 2 %}
PetscErrorCode assemble(DM da, Mat formmat, DM s1da, DM s2da {{ fieldargs }} {{ constantargs }})
{% endif %}
 {% if formdim == 1 %}
PetscErrorCode assemble(DM da, Vec formvec, DM s1da {{ fieldargs }} {{ constantargs }}) 
{% endif %}
 {% if formdim == 0 %}
PetscScalar assemble(DM da {{ fieldargs }} {{ constantargs }})
{% endif %}

{

 {% if formdim == 2 %}
 PetscScalar vals[{{ space1.nbasis_total }} * {{ space1.ndofs }}][{{ space2.nbasis_total }} * {{ space2.ndofs }}] = { {0.,},};
    PetscInt     cols[{{ space2.nbasis_total }} * {{ space2.ndofs }}];
    PetscInt     rows[{{ space1.nbasis_total }} * {{ space1.ndofs }}];
 {% endif %}
 {% if formdim == 1 %}
 PetscScalar vals[{{ space1.nbasis_total }} * {{ space1.ndofs }}] = {0.,};
 {% if ndim == 1 %}
 PetscScalar **data_formvec;
      {% endif %}
 {% if ndim == 2 %}
 PetscScalar ***data_formvec;
      {% endif %}
 {% if ndim == 3 %}
 PetscScalar ****data_formvec;
      {% endif %}
 {% endif %}

 
 {% if formdim == 0 %}
 PetscScalar	vals[1] = {0.0,};
 PetscScalar formsum[1] = {0.0,};
 {% endif %}

  PetscErrorCode ierr;
  PetscInt i,j,k; //spatial loop indices
   PetscInt lx,ly,lz; //rows/cols indices
   PetscInt d; //dof index
  PetscInt xs,xm,ys,ym,zs,zm,xmax,ymax,zmax,extrax,extray,extraz;
  PetscInt is,ie,js,je,ks,ke;
   PetscInt compoffset;

 {% if formdim == 2 %}
 PetscInt x2s,y2s,z2s;
 PetscInt nGhost2x,nGhost2y,nGhost2z;
 PetscInt epe1,epe2;
 PetscInt nGhost1x,nGhost1y,nGhost1z;
  {% for ci2 in range(space2.ncomp) %}
  PetscInt idx2_{{ ci2 }}[{{ space2.nbasis_x[ci2] }}][{{ space2.nbasis_y[ci2] }}][{{ space2.nbasis_z[ci2] }}][{{ space2.ndofs }}];
  {% endfor %}
  {% endif %}
  
 {% if formdim >= 1 %}
  PetscInt x1s,y1s,z1s;
 {% for ci1 in range(space1.ncomp) %}
  PetscInt idx1_{{ ci1 }}[{{ space1.nbasis_x[ci1] }}][{{ space1.nbasis_y[ci1] }}][{{ space1.nbasis_z[ci1] }}][{{ space1.ndofs }}];
  {% endfor %}
  {% endif %}

 {% for field in fieldlist %}
 PetscInt {{field.name}}_offset;
 // THIS SIZING IS WRONG - ie should be 1D with nbasis * ndofs...
 PetscScalar	{{field.name}}_vals[{{ field.nbasis_total }}][{{ field.ndofs }}] = { { 0.,},};
 {% for k in range(field.ncomp) %}
 PetscInt {{field.name}}_idx_{{k}}[{{ field.nbasis_x[k] }}][{{ field.nbasis_y[k] }}][{{ field.nbasis_z[k] }}][{{ field.ndofs }}];
    {% endfor %}

 {% if ndim == 1 %}
  PetscScalar **data_{{field.name}};
      {% endif %}
 {% if ndim == 2 %}
  PetscScalar ***data_{{field.name}};
      {% endif %}
 {% if ndim == 3 %}
  PetscScalar ****data_{{field.name}};
      {% endif %}
  {% endfor %}

 {% for field in fieldlist %}
  ierr = DMStagVecGetArrayDOFRead(da_{{field.name}},{{field.name}},&data_{{field.name}});CHKERRQ(ierr);
  {% endfor %}
  
  //Get the data out of Vec formvec
    {% if formdim == 1 %}
    ierr = DMStagVecGetArrayDOF(s1da,formvec,&data_formvec);CHKERRQ(ierr);
    {% endif %}


	//get DMStag ranges
  ierr = DMStagGetCorners(da,&xs,&ys,&zs,&xm,&ym,&zm,&extrax,&extray,&extraz);CHKERRQ(ierr);
   ierr = DMStagGetGlobalSizes(da,&xmax,&ymax,&zmax);CHKERRQ(ierr);
      {% if formdim >= 1 %}
 ierr = DMStagGetGhostCorners(s1da,&x1s,&y1s,&z1s,&nGhost1x,&nGhost1y,&nGhost1z);CHKERRQ(ierr);
      {% endif %}
      {% if formdim == 2 %}
 ierr = DMStagGetGhostCorners(s2da,&x2s,&y2s,&z2s,&nGhost2x,&nGhost2y,&nGhost2z);CHKERRQ(ierr);
      {% endif %}


// get epe, epr and epl as needed
      {% if formdim == 2 %}
ierr = DMStagGetEntriesPerElement(s1da,&epe1);CHKERRQ(ierr);
ierr = DMStagGetEntriesPerElement(s2da,&epe2);CHKERRQ(ierr);
     {% if ndim == 2 %}
    const PetscInt epr1 = nGhost1x;
    const PetscInt epr2 = nGhost2x;
        {% endif %}
         {% if ndim == 3 %}
   const PetscInt epr1 = nGhost1x;
   const PetscInt epl1 = nGhost1x*nGhost1y;
   const PetscInt epr2 = nGhost2x;
   const PetscInt epl2 = nGhost2x*nGhost2y;
           {% endif %}
      {% endif %}

// ADD A BLOCKS LOOP HERE
// based on maxnblocks AND periodicity, divide i,j,k into iteration sets
// each set has idx values (offsets) and tabulations

// FIX THIS STUFF!
// BLOCK INDICES!
  ks = zs;
  ke = zs+zm;
  
  js = ys;
  je = ys+ym;
  
  is = xs;
  ie = xs+xm;
  
  // BLOCK INDICES!
 {% if formdim >= 1 %}
  {% for ci1 in range(space1.ncomp) %}
  const PetscInt cell1x_{{ ci1 }}[{{ space1.nbasis_x[ci1] }}] = {{ space1.cellx[ci1] }};
  const PetscInt cell1y_{{ ci1 }}[{{ space1.nbasis_y[ci1] }}] = {{ space1.celly[ci1] }};
  const PetscInt cell1z_{{ ci1 }}[{{ space1.nbasis_z[ci1] }}] = {{ space1.cellz[ci1] }};
  
 {% for lx in range(space1.nbasis_x[ci1]) %}
 {% for ly in range(space1.nbasis_y[ci1]) %}
 {% for lz in range(space1.nbasis_z[ci1]) %}
  {% for d in range(space1.ndofs) %}
  // DOFNUM HERE NEEDS SOME THOUGHT...
  DMStagGetLocationSlot(da, {{ space1.location[ci1][lx][ly][lz] }}, {{ space1.dofnum[ci1][lx][ly][lz][d] }}, &idx1_{{ ci1 }} [{{lx}}][{{ly}}][{{lz}}][{{d}}]);
    {% endfor %}
    {% endfor %}
    {% endfor %}
    {% endif %}

  // BLOCK INDICES!
 {% if formdim == 2 %}
  {% for ci2 in range(space2.ncomp) %}
  const PetscInt cell2x_{{ ci2 }}[{{ space2.nbasis_x[ci2] }}] = {{ space2.cellx[ci2] }};
  const PetscInt cell2y_{{ ci2 }}[{{ space2.nbasis_x[ci2] }}] = {{ space2.celly[ci2] }};
  const PetscInt cell2z_{{ ci2 }}[{{ space2.nbasis_x[ci2] }}] = {{ space2.cellz[ci2] }};
 {% for lx in range(space2.nbasis_x[ci2]) %}
 {% for ly in range(space2.nbasis_y[ci2]) %}
 {% for lz in range(space2.nbasis_z[ci2]) %}
  {% for d in range(space2.ndofs) %}
  // DOFNUM HERE NEEDS SOME THOUGHT...
  DMStagGetLocationSlot(da, {{ space2.location[ci2][lx][ly][lz] }}, {{ space2.dofnum[ci2][lx][ly][lz][d] }}, &idx2_{{ ci2 }} [{{lx}}][{{ly}}][{{lz}}][{{d}}]);
    {% endfor %}
    {% endfor %}
    {% endfor %}
    {% endif %}

  // BLOCK INDICES!
 {% for field in fieldlist %}
  {% for k in range(field.ncomp) %}  
 const PetscInt {{field.name}}_cellx_{{k}}[{{ field.nbasis_x[k] }}] = {{ field.cellx[k] }};
 const PetscInt {{field.name}}_celly_{{k}}[{{ field.nbasis_y[k] }}] = {{ field.celly[k] }};
 const PetscInt {{field.name}}_cellz_{{k}}[{{ field.nbasis_z[k] }}] = {{ field.cellz[k] }};
  
 {% for lx in range(field.nbasis_x[k]) %}
 {% for ly in range(field.nbasis_y[k]) %}
 {% for lz in range(field.nbasis_z[k]) %}
 {% for d in range(field.ndofs) %}
  // DOFNUM HERE NEEDS SOME THOUGHT...
  DMStagGetLocationSlot(da, {{ field.location[k][lx][ly][lz] }}, {{ field.dofnum[k][lx][ly][lz][d] }} , &{{field.name}}_idx_{{k}} [{{lx}}][{{ly}}][{{lz}}][{{d}}]);
    {% endfor %}
    {% endfor %}
    {% endfor %}
        {% endfor %}
    {% endfor %}
    {% endfor %}    

 {% for tabulation in tabulations %}
  // BLOCK INDICES!
  // SHOULD TAKE INTO ACCOUNT SHIFT AXIS...
 const   PetscScalar {{ tabulation.name }}[{{ tabulation.npts }}][{{ tabulation.nbasis }}] = {{ tabulation.values }};
 {% endfor %}
 
for (k=ks; k<ke; k++) {
   for (j=js; j<je; j++) {
      for (i=is; i<ie; i++) {

	    
		//printf("start %i %i %i: %i %i %i\n",i,j,k,xs,xm,xmax);
	      //4:   if (dim == 1) {
//135:     for (idx=0; idx<n; ++idx) {
//136:       const PetscInt eLocal = pos[idx].i - startGhost[0]; /* Local element number */
//137:       ix[idx] = eLocal * epe + stag->locationOffsets[pos[idx].loc] + pos[idx].c;
//138:     }
//139:   } else if (dim == 2) {
//140:     const PetscInt epr = stag->nGhost[0];
//141:     DMStagGetGhostCorners(dm,&startGhost[0],&startGhost[1],NULL,NULL,NULL,NULL);
//142:     for (idx=0; idx<n; ++idx) {
//143:       const PetscInt eLocalx = pos[idx].i - startGhost[0];
//144:       const PetscInt eLocaly = pos[idx].j - startGhost[1];
//145:       const PetscInt eLocal = eLocalx + epr*eLocaly;
//146:       ix[idx] = eLocal * epe + stag->locationOffsets[pos[idx].loc] + pos[idx].c;
//147:     }
//148:   } else if (dim == 3) {
//149:     const PetscInt epr = stag->nGhost[0];
//150:     const PetscInt epl = stag->nGhost[0]*stag->nGhost[1];
//151:     DMStagGetGhostCorners(dm,&startGhost[0],&startGhost[1],&startGhost[2],NULL,NULL,NULL);
//152:     for (idx=0; idx<n; ++idx) {
//153:       const PetscInt eLocalx = pos[idx].i - startGhost[0];
//154:       const PetscInt eLocaly = pos[idx].j - startGhost[1];
//155:       const PetscInt eLocalz = pos[idx].k - startGhost[2];
//156:       const PetscInt eLocal  = epl*eLocalz + epr*eLocaly + eLocalx;
//157:       ix[idx] = eLocal * epe + stag->locationOffsets[pos[idx].loc] + pos[idx].c;
//158:     }

	      


  // FIX ROWS/COLS TO BE REPLACED WITH SETTINGS ROWS/COLS FOR IS,JS,KS and A constant offset
		 {% if formdim == 2 %}
       {% for ci1 in range(space1.ncomp) %}
       compoffset = 0;
		for (lx=0;lx<{{ space1.nbasis_x[ci1] }};lx++) {
		for (ly=0;ly<{{ space1.nbasis_y[ci1] }};ly++) {
		for (lz=0;lz<{{ space1.nbasis_z[ci1] }};lz++) {
		  for (d=0;d<{{ space1.ndofs }};d++){
		  const PetscInt ii = i + cell1x_{{ci1}}[lx]- x1s;
		  const PetscInt jj = j + cell1y_{{ci1}}[ly]- y1s;
		  const PetscInt kk = k + cell1z_{{ci1}}[lz]- z1s;
		{% if ndim == 1 %}
		const PetscInt eLocal = ii * epe1;
		// THIS INDEXING FOR VECTOR-VALUED MIGHT BE WRONG...
		rows [compoffset + lz + {{  space1.nbasis_z[ci1]  }} * (ly + {{ space1.nbasis_y[ci1]  }} * lx)][d] =  eLocal + idx1_{{ ci1 }} [lx][ly][lz][d];
		{% endif %}
		{% if ndim == 2 %}
		const PetscInt eLocal = (ii + jj*epr1) * epe1;
		rows [compoffset + lz + {{  space1.nbasis_z[ci1]  }} * (ly + {{ space1.nbasis_y[ci1]  }} * lx)][d] =  eLocal + idx1_{{ ci1 }} [lx][ly][lz][d];
		{% endif %}
		{% if ndim == 3 %}
		const PetscInt eLocal = (ii + jj*epr1 + kk*epl1) * epe1;
		rows [compoffset + lz + {{  space1.nbasis_z[ci1]  }} * (ly + {{ space1.nbasis_y[ci1]  }} * lx)][d] =  eLocal + idx1_{{ ci1 }} [lx][ly][lz][d];
		{% endif %}
		}}}
		compoffset = compoffset + {{  space1.nbasis[ci1]  }};
      {% endfor %}


       {% for ci2 in range(space2.ncomp) %}
       compoffset = 0;
		for (lx=0;lx<{{ space2.nbasis_x[ci2] }};lx++) {
		for (ly=0;ly<{{ space2.nbasis_y[ci2] }};ly++) {
		for (lz=0;lz<{{ space2.nbasis_z[ci2] }};lz++) {
		  for (d=0;d<{{ space2.ndofs }};d++){
		  const PetscInt ii = i + cell2x_{{ci2}}[lx]- x2s;
		  const PetscInt jj = j + cell2y_{{ci2}}[ly]- y2s;
		  const PetscInt kk = k + cell2z_{{ci2}}[lz]- z2s;
		{% if ndim == 1 %}
		// THIS INDEXING FOR VECTOR-VALUED MIGHT BE WRONG...
		const PetscInt eLocal = ii * epe2;
		cols [compoffset + lz + {{  space2.nbasis_z[ci2]  }} * (ly + {{ space2.nbasis_y[ci2]  }} * lx)][d] =  eLocal + idx2_{{ ci2 }} [lx][ly][lz][d];
		{% endif %}
		{% if ndim == 2 %}
		const PetscInt eLocal = (ii + jj*epr2) * epe2;
		cols [compoffset + lz + {{  space2.nbasis_z[ci2]  }} * (ly + {{ space2.nbasis_y[ci2]  }} * lx)][d] =  eLocal + idx2_{{ ci2 }} [lx][ly][lz][d];
		{% endif %}
		{% if ndim == 3 %}
		const PetscInt eLocal = (ii + jj*epr2 + kk*epl2) * epe2;
		cols [compoffset + lz + {{  space2.nbasis_z[ci2]  }} * (ly + {{ space2.nbasis_y[ci2]  }} * lx)][d] =  eLocal + idx2_{{ ci2 }} [lx][ly][lz][d];
		{% endif %}
		}}}
		compoffset = compoffset + {{  space2.nbasis[ci2]  }};
      {% endfor %}
		{% endif %}
		
		
//extract element dofs from local dofs
// SHOULD FIX VALS HERE SO 1D ARRAY

{% for field in fieldlist %}
{{field.name}}_offset = 0;
{% for k in range(field.ncomp) %}
for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (ly=0;ly<{{ field.nbasis_y[k] }};ly++){
for (lz=0;lz<{{ field.nbasis_z[k] }};lz++){
for (d=0;d<{{ field.ndofs }};d++){
  const PetscInt ii = i + {{field.name}}_cellx_{{k}}[lx][d];
  const PetscInt jj = j + {{field.name}}_celly_{{k}}[ly][d];
  const PetscInt kk = k + {{field.name}}_cellz_{{k}}[lz][d];
  // THIS INDEXING FOR VECTOR-VALUED MIGHT BE WRONG...
{% if ndim == 1 %}
{{field.name}}_vals [fieldoffset + lz + {{  field.nbasis_z[k]  }} * (ly + {{ field.nbasis_y[k]  }} * lx)][d] = data_{{field.name}} [ii][{{field.name}}_idx_{{k}}[lx][ly][lz][d]];
{% endif %}
{% if ndim == 2 %}
{{field.name}}_vals [fieldoffset + lz + {{  field.nbasis_z[k]  }} * (ly + {{ field.nbasis_y[k]  }} * lx)][d] = data_{{field.name}} [jj][ii][{{field.name}}_idx_{{k}}[lx][ly][lz][d]];
{% endif %}
{% if ndim == 3 %}
{{field.name}}_vals [fieldoffset + lz + {{  field.nbasis_z[k]  }} * (ly + {{ field.nbasis_y[k]  }} * lx)][d] = data_{{field.name}} [kk][jj][ii][{{field.name}}_idx_{{k}}[lx][ly][lz][d]];
{% endif %}
//printf("{{field.name}} {{k}} : %i %i %i : %i %i\n",i,j,k,lx,ii);
}}}}
fieldoffset = fieldoffset + {{ field.nbasis[k] }};
{% endfor %}
{% endfor %}
		
				//printf("fields\n");

		//compute the element tensor
		
		    {% if formdim == 2 %}
	ierr = PetscMemzero(vals,sizeof(PetscScalar[{{ space1.nbasis_total }} * {{ space1.ndofs }}][{{ space2.nbasis_total }} * {{ space2.ndofs }}])); CHKERRQ(ierr);
				{% endif %}
		    {% if formdim == 1 %}
	ierr = PetscMemzero(vals,sizeof(PetscScalar[{{ space1.nbasis_total }} * {{ space1.ndofs }}])); CHKERRQ(ierr);
				{% endif %}
		    {% if formdim == 0 %}
		    vals[0] = 0.0;
				{% endif %}

				{% if not kernelstr == '' %}
		{{kernelname}}(vals
				 {% for field in fieldplusconstantslist %}
				 ,{{field}}
				{% endfor %}
				 {% for tabulation in tabulations %}
				 ,{{tabulation.name}}
				{% endfor %}
			);
			  				{% endif %}

			//unsplat vals
		

		
		//Put the element tensor into the local tensor
		{% if formdim == 2 %}
        ierr = MatSetValuesLocal(formmat,{{ space1.nbasis_total }} * {{ space1.ndofs }},rows,{{ space2.nbasis_total }} * {{ space2.ndofs }},cols,*vals,ADD_VALUES);CHKERRQ(ierr);
		{% endif %}
		
		{% if formdim == 1 %}
		{{ SETVALS() }}
		{% endif %}
		
		{% if formdim == 0 %}
		formsum[0] = formsum[0] + vals[0];
		{% endif %}
		
								//printf("tensor set\n");

				//printf("end %i %i %i: %i %i\n",i,j,k,xs,xm);
				
       }}}

//restore fields arrays and data
 {% for field in fieldlist %}
    ierr = DMStagVecRestoreArrayDOFRead(da_{{field.name}},{{field.name}},&data_{{field.name}});CHKERRQ(ierr);
   {% endfor %}
  
 {% if formdim == 1 %}
//restore data in Vec v
    ierr = DMStagVecRestoreArray(s1da,formvec,&data_formvec);CHKERRQ(ierr);
{% endif %}
 
  {% if formdim == 0 %}
return formsum[0];
{% endif %}

  PetscFunctionReturn(0);
}
