

{# ********************************************* #}

{%macro CLEAR_FIELD(field,k) -%}
{%set ab = a~'_'~b %}
ierr = PetscMemzero({{ 'C01_'~field.name~'_'~k }},sizeof(PetscScalar[{{field.ndofs}}][{{ npts_z }}][{{field.nbasis_x[k] }}][{{ field.nbasis_y[k] }}]));CHKERRQ(ierr);
ierr = PetscMemzero({{ 'C02_'~field.name~'_'~k }},sizeof(PetscScalar[{{field.ndofs}}][{{ npts_y }}][{{ npts_z }}][{{ field.nbasis_x[k] }}]));CHKERRQ(ierr);
ierr = PetscMemzero({{ 'C0_'~field.name~'_'~k }},sizeof(PetscScalar[{{field.ndofs}}][{{ npts_x }}][{{ npts_y }}][{{ npts_z }}]));CHKERRQ(ierr);
{% endmacro %}

{# ********************************************* #}

{%macro EXTRACT_FIELD(field,k) -%}
#define kk (k*{{field.name}}_{{k}}_offset_mult_z[bi_{{field.name}}_z_{{k}}][lz] + {{field.name}}_{{k}}_offsets_z[bi_{{field.name}}_z_{{k}}][lz]) 
#define jj (j*{{field.name}}_{{k}}_offset_mult_y[bi_{{field.name}}_y_{{k}}][ly] + {{field.name}}_{{k}}_offsets_y[bi_{{field.name}}_y_{{k}}][ly]) 
#define ii (i*{{field.name}}_{{k}}_offset_mult_x[bi_{{field.name}}_x_{{k}}][lx] + {{field.name}}_{{k}}_offsets_x[bi_{{field.name}}_x_{{k}}][lx]) 

for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (ly=0;ly<{{ field.nbasis_y[k] }};ly++){
for (lz=0;lz<{{ field.nbasis_z[k] }};lz++){
for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (d=0;d<{{ field.ndofs }};d++){
{% if ndim == 3 %}
C01_{{ field.name }}_{{k}}[d][qz][lx][ly] += data_{{field.name}}_{{k}}[kk][jj][ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
{% endif %}
{% if ndim == 2 %}
C01_{{ field.name }}_{{k}}[d][qz][lx][ly] += data_{{field.name}}_{{k}}[jj][ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
{% endif %}
{% if ndim == 1 %}
C01_{{ field.name }}_{{k}}[d][qz][lx][ly] += data_{{field.name}}_{{k}}[ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
{% endif %}
}}}}}

for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (ly=0;ly<{{ field.nbasis_y[k] }};ly++){
for (qy=0;qy<{{ npts_y }};qy++) { //loop over quadrature pts in y
for (d=0;d<{{ field.ndofs }};d++){
C02_{{ field.name }}_{{k}}[d][qy][qz][lx] += C01_{{ field.name }}_{{k}}[d][qz][lx][ly] * {{field.name}}_{{k}}_basis_y[bi_{{field.name}}_y_{{k}}][qy][ly];
}}}}}

for (qy=0;qy<{{ npts_y }};qy++) { //loop over quadrature pts in y
for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (qx=0;qx<{{ npts_x }};qx++) { //loop over quadrature pts in x
for (d=0;d<{{ field.ndofs }};d++){
C0_{{  field.name }}_{{k}}[d][qx][qy][qz] += C02_{{ field.name }}_{{k}}[d][qy][qz][lx] * {{field.name}}_{{k}}_basis_x[bi_{{field.name}}_x_{{k}}][qx][lx];
}}}}}

#undef ii
#undef jj
#undef kk
{% endmacro %}

{# ********************************************* #}

{%macro CLEAR_DERIVS(field,k) -%}
{%set ab = a~'_'~b %}
ierr = PetscMemzero({{ 'D01_'~field.name~'_'~k }},sizeof(PetscScalar[3][{{field.ndofs}}][{{ npts_z }}][{{field.nbasis_x[k] }}][{{ field.nbasis_y[k] }}]));CHKERRQ(ierr);
ierr = PetscMemzero({{ 'D02_'~field.name~'_'~k }},sizeof(PetscScalar[3][{{field.ndofs}}][{{ npts_y }}][{{ npts_z }}][{{ field.nbasis_x[k] }}]));CHKERRQ(ierr);
ierr = PetscMemzero({{ 'D0_'~field.name~'_'~k }},sizeof(PetscScalar[3][{{field.ndofs}}][{{ npts_x }}][{{ npts_y }}][{{ npts_z }}]));CHKERRQ(ierr);
{% endmacro %}

{# ********************************************* #}

{%macro EXTRACT_DERIVS(field,k) -%}
#define kk (k*{{field.name}}_{{k}}_offset_mult_z[bi_{{field.name}}_z_{{k}}][lz] + {{field.name}}_{{k}}_offsets_z[bi_{{field.name}}_z_{{k}}][lz]) 
#define jj (j*{{field.name}}_{{k}}_offset_mult_y[bi_{{field.name}}_y_{{k}}][ly] + {{field.name}}_{{k}}_offsets_y[bi_{{field.name}}_y_{{k}}][ly]) 
#define ii (i*{{field.name}}_{{k}}_offset_mult_x[bi_{{field.name}}_x_{{k}}][lx] + {{field.name}}_{{k}}_offsets_x[bi_{{field.name}}_x_{{k}}][lx]) 

for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (ly=0;ly<{{ field.nbasis_y[k] }};ly++){
for (lz=0;lz<{{ field.nbasis_z[k] }};lz++){
for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (d=0;d<{{ field.ndofs }};d++){
{% if ndim == 3 %}
D01_{{ field.name }}_{{k}}[0][d][qz][lx][ly] += data_{{field.name}}_{{k}}[kk][jj][ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
D01_{{ field.name }}_{{k}}[1][d][qz][lx][ly] += data_{{field.name}}_{{k}}[kk][jj][ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
D01_{{ field.name }}_{{k}}[2][d][qz][lx][ly] += data_{{field.name}}_{{k}}[kk][jj][ii][d] * {{field.name}}_{{k}}_derivs_z[bi_{{field.name}}_z_{{k}}][qz][lz];
{% endif %}
{% if ndim == 2 %}
D01_{{ field.name }}_{{k}}[0][d][qz][lx][ly] += data_{{field.name}}_{{k}}[jj][ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
D01_{{ field.name }}_{{k}}[1][d][qz][lx][ly] += data_{{field.name}}_{{k}}[jj][ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
D01_{{ field.name }}_{{k}}[2][d][qz][lx][ly] += data_{{field.name}}_{{k}}[jj][ii][d] * {{field.name}}_{{k}}_derivs_z[bi_{{field.name}}_z_{{k}}][qz][lz];
{% endif %}
{% if ndim == 1 %}
D01_{{ field.name }}_{{k}}[0][d][qz][lx][ly] += data_{{field.name}}_{{k}}[ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
D01_{{ field.name }}_{{k}}[1][d][qz][lx][ly] += data_{{field.name}}_{{k}}[ii][d] * {{field.name}}_{{k}}_basis_z[bi_{{field.name}}_z_{{k}}][qz][lz];
D01_{{ field.name }}_{{k}}[2][d][qz][lx][ly] += data_{{field.name}}_{{k}}[ii][d] * {{field.name}}_{{k}}_derivs_z[bi_{{field.name}}_z_{{k}}][qz][lz];
{% endif %}
}}}}}

for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (ly=0;ly<{{ field.nbasis_y[k] }};ly++){
for (qy=0;qy<{{ npts_y }};qy++) { //loop over quadrature pts in y
for (d=0;d<{{ field.ndofs }};d++){
D02_{{ field.name }}_{{k}}[0][d][qy][qz][lx] += D01_{{ field.name }}_{{k}}[0][d][qz][lx][ly] * {{field.name}}_{{k}}_basis_y[bi_{{field.name}}_y_{{k}}][qy][ly];
D02_{{ field.name }}_{{k}}[1][d][qy][qz][lx] += D01_{{ field.name }}_{{k}}[1][d][qz][lx][ly] * {{field.name}}_{{k}}_derivs_y[bi_{{field.name}}_y_{{k}}][qy][ly];
D02_{{ field.name }}_{{k}}[2][d][qy][qz][lx] += D01_{{ field.name }}_{{k}}[2][d][qz][lx][ly] * {{field.name}}_{{k}}_basis_y[bi_{{field.name}}_y_{{k}}][qy][ly];
}}}}}

for (qy=0;qy<{{ npts_y }};qy++) { //loop over quadrature pts in y
for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (qx=0;qx<{{ npts_x }};qx++) { //loop over quadrature pts in x
for (d=0;d<{{ field.ndofs }};d++){
D0_{{  field.name }}_{{k}}[0][d][qx][qy][qz] += D02_{{ field.name }}_{{k}}[0][d][qy][qz][lx] * {{field.name}}_{{k}}_derivs_x[bi_{{field.name}}_x_{{k}}][qx][lx];
D0_{{  field.name }}_{{k}}[1][d][qx][qy][qz] += D02_{{ field.name }}_{{k}}[1][d][qy][qz][lx] * {{field.name}}_{{k}}_basis_x[bi_{{field.name}}_x_{{k}}][qx][lx];
D0_{{  field.name }}_{{k}}[2][d][qx][qy][qz] += D02_{{ field.name }}_{{k}}[2][d][qy][qz][lx] * {{field.name}}_{{k}}_basis_x[bi_{{field.name}}_x_{{k}}][qx][lx];
}}}}}

#undef ii
#undef jj
#undef kk
{% endmacro %}

{# ********************************************* #}

{%macro compute_J(coords) -%}
{{ CLEAR_DERIVS(coords,0) }}
{{ EXTRACT_DERIVS(coords,0) }}

LOOP_QUAD; LOOP_NDIM2;
PJ[n1][n2] = D0_{{  coords.name }}_0[n2][n1][qx][qy][qz]; //NOTE flip of n1/n2
END_NDIM2; END_QUAD;
{% endmacro %}

{# ********************************************* #}

{%macro compute_detJ() -%}

LOOP_QUAD;
{% if ndim == 1 %}
PDETJ = PJ[0][0];
{% endif %}
{% if ndim == 2 %}
PDETJ = PJ[0][0]*PJ[1][1] - PJ[1][0]*PJ[0][1];
{% endif %}
{% if ndim == 3 %}
PDETJ = PJ[0][0]*((PJ[1][1]*PJ[2][2]) - (PJ[2][1]*PJ[1][2])) -PJ[0][1]*(PJ[1][0]*PJ[2][2] - PJ[2][0]*PJ[1][2]) + PJ[0][2]*(PJ[1][0]*PJ[2][1] - PJ[2][0]*PJ[1][1]);
{% endif %}
END_QUAD;

{% endmacro %}

{# ********************************************* #}

{%macro compute_JTinv() -%}

LOOP_QUAD; LOOP_NDIM2;
PJTINV[n1][n2] = PJ[n1][n2]; //WRONG FIX IT
END_NDIM2; END_QUAD;

{% endmacro %}


{# ********************************************* #}

{%macro l2_eval(field,coords) -%}
{{ CLEAR_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,0) }}
{{ compute_J(coords) }}
{{ compute_detJ() }}
LOOP_QUAD;
for (s=0;s<{{ field.ndofs }};s++){
PVALS = C0_{{  field.name }}_0[s][qx][qy][qz]/ PDETJ;
}
END_QUAD;
{% endmacro %}


{# ********************************************* #}
{%macro h1_eval(field) -%}
{{ CLEAR_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,0) }}
LOOP_QUAD;
for (s=0;s<{{ field.ndofs }};s++){
PVALS = C0_{{  field.name }}_0[s][qx][qy][qz];
}
END_QUAD;
{% endmacro %}

{# ********************************************* #}

{%macro hdiv_eval(field,coords) -%}
{% if ndim == 3 %}
{{ CLEAR_FIELD(field,0) }}
{{ CLEAR_FIELD(field,1) }}
{{ CLEAR_FIELD(field,2) }}
{{ EXTRACT_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,1) }}
{{ EXTRACT_FIELD(field,2) }}
{{ compute_J(coords) }}
{{ compute_detJ() }}
LOOP_QUAD
for (s=0;s<3;s++){
PVALS = (C0_{{  field.name }}_0[0][qx][qy][qz]* PJ[s][0] + C0_{{  field.name }}_1[0][qx][qy][qz] * PJ[s][1] + C0_{{  field.name }}_2[0][qx][qy][qz] * PJ[s][2]) / PDETJ;
}
END_QUAD;
{% endif %}
{% if ndim == 2 %}
{{ CLEAR_FIELD(field,0) }}
{{ CLEAR_FIELD(field,1) }}
{{ EXTRACT_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,1) }}
{{ compute_J(coords) }}
{{ compute_detJ() }}
LOOP_QUAD
for (s=0;s<2;s++){
PVALS = (C0_{{  field.name }}_0[0][qx][qy][qz]* PJ[s][0] + C0_{{  field.name }}_1[0][qx][qy][qz] * PJ[s][1]) / PDETJ;
}
END_QUAD;
{% endif %}
{% if ndim == 1 %}
{{ CLEAR_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,0) }}
{{ compute_J(coords) }}
{{ compute_detJ() }}
LOOP_QUAD
for (s=0;s<1;s++){
PVALS = (C0_{{  field.name }}_0[0][qx][qy][qz]* PJ[s][0]) / PDETJ;
}
END_QUAD;
{% endif %}
{% endmacro %}

{# ********************************************* #}

{%macro hcurl_eval(field) -%}
{% if ndim == 3 %}
{{ CLEAR_FIELD(field,0) }}
{{ CLEAR_FIELD(field,1) }}
{{ CLEAR_FIELD(field,2) }}
{{ EXTRACT_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,1) }}
{{ EXTRACT_FIELD(field,2) }}
{{ compute_J(coords) }}
{{ compute_JTinv() }}
LOOP_QUAD
for (s=0;s<3;s++){
PVALS = (C0_{{  field.name }}_0[0][qx][qy][qz]* PJTINV[s][0] + C0_{{  field.name }}_1[0][qx][qy][qz] * PJTINV[s][1] + C0_{{  field.name }}_2[0][qx][qy][qz] * PJTINV[s][2]);
}
END_QUAD;
{% endif %}
{% if ndim == 2 %}
{{ CLEAR_FIELD(field,0) }}
{{ CLEAR_FIELD(field,1) }}
{{ EXTRACT_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,1) }}
{{ compute_J(coords) }}
{{ compute_JTinv() }}
LOOP_QUAD
for (s=0;s<2;s++){
PVALS = (C0_{{  field.name }}_0[0][qx][qy][qz]* PJTINV[s][0] + C0_{{  field.name }}_1[0][qx][qy][qz] * PJTINV[s][1]);
}
END_QUAD;
{% endif %}
{% if ndim == 1 %}
{{ CLEAR_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,0) }}
{{ compute_J(coords) }}
{{ compute_JTinv() }}
LOOP_QUAD
for (s=0;s<1;s++){
PVALS = (C0_{{  field.name }}_0[0][qx][qy][qz]* PJTINV[s][0]);
}
END_QUAD;
{% endif %}
{% endmacro %}

{# ********************************************* #}






#include <petsc.h>
#include "math.h"
#include <stdio.h>

PetscScalar assemble(DM da {{ valsargs }} {{ fieldargs }} )

{




  PetscErrorCode ierr;
  PetscInt i,j,k; //element loop indices
   PetscInt qx,qy,qz; //quad indices
   PetscInt lx,ly,lz; //basis indices
   PetscInt d,d1,d2; //field dof indices
   PetscInt n1,n2; //dimension indices
   PetscInt s,s1,s2; //eval coeff dof indices
  PetscInt xs,xm,ys,ym,zs,zm,xmax,ymax,zmax;

//J[a][b] is a-th component, b-th derivative ie J[0][0] is dx/dxhat, J[1][2] is dy/dzhat, etc.
PetscScalar J[{{ npts_x }}][{{ npts_y }}][{{ npts_z }}][{{ ndim }}][{{ ndim }}];
PetscScalar detJ[{{ npts_x }}][{{ npts_y }}][{{ npts_z }}];
PetscScalar JTinv[{{ npts_x }}][{{ npts_y }}][{{ npts_z }}][{{ ndim }}][{{ ndim }}];

#define PDETJ detJ[qx][qy][qz]
#define PJ J[qx][qy][qz]
#define PJTINV JTinv[qx][qy][qz]

#define LOOP_QUAD   for (qx=0;qx<{{ npts_x }};qx++) { \
                    for (qy=0;qy<{{ npts_y }};qy++) { \
                    for (qz=0;qz<{{ npts_z }};qz++) { 
#define END_QUAD }}}
				
#define LOOP_NDIM2   for (n1=0;n1<{{ ndim }};n1++) { \
                    for (n2=0;n2<{{ ndim }};n2++) {
#define END_NDIM2 }}
						
 {% for field in fieldlist %}
 {% for k in range(field.ncomp) %}
const   PetscInt {{field.name}}_{{k}}_offsets_x[{{ field.nblocks_x[k] }}][{{ field.nbasis_x[k] }}] = {{ field.offsets_x[k] }};
const   PetscInt {{field.name}}_{{k}}_offsets_y[{{ field.nblocks_y[k] }}][{{ field.nbasis_y[k] }}] = {{ field.offsets_y[k] }};
const   PetscInt {{field.name}}_{{k}}_offsets_z[{{ field.nblocks_z[k] }}][{{ field.nbasis_z[k] }}] = {{ field.offsets_z[k] }};
const   PetscInt {{field.name}}_{{k}}_offset_mult_x[{{ field.nblocks_x[k] }}][{{ field.nbasis_x[k] }}] = {{ field.offset_mult_x[k] }};
const   PetscInt {{field.name}}_{{k}}_offset_mult_y[{{ field.nblocks_y[k] }}][{{ field.nbasis_y[k] }}] = {{ field.offset_mult_y[k] }};
const   PetscInt {{field.name}}_{{k}}_offset_mult_z[{{ field.nblocks_z[k] }}][{{ field.nbasis_z[k] }}] = {{ field.offset_mult_z[k] }};

const   PetscScalar {{field.name}}_{{k}}_basis_x[{{ field.nblocks_x[k] }}][{{ npts_x }}][{{ field.nbasis_x[k] }}] = {{ field.basis_x[k] }};
const   PetscScalar {{field.name}}_{{k}}_basis_y[{{ field.nblocks_y[k] }}][{{ npts_y }}][{{ field.nbasis_y[k] }}] = {{ field.basis_y[k] }};
const   PetscScalar {{field.name}}_{{k}}_basis_z[{{ field.nblocks_z[k] }}][{{ npts_z }}][{{ field.nbasis_z[k] }}] = {{ field.basis_z[k] }};
const   PetscScalar {{field.name}}_{{k}}_derivs_x[{{ field.nblocks_x[k] }}][{{ npts_x }}][{{ field.nbasis_x[k] }}] = {{ field.derivs_x[k] }};
const   PetscScalar {{field.name}}_{{k}}_derivs_y[{{ field.nblocks_y[k] }}][{{ npts_y }}][{{ field.nbasis_y[k] }}] = {{ field.derivs_y[k] }};
const   PetscScalar {{field.name}}_{{k}}_derivs_z[{{ field.nblocks_z[k] }}][{{ npts_z }}][{{ field.nbasis_z[k] }}] = {{ field.derivs_z[k] }};

   PetscInt bi_{{field.name}}_x_{{k}} = -1000;
   PetscInt bi_{{field.name}}_y_{{k}} = -1000;
   PetscInt bi_{{field.name}}_z_{{k}} = -1000;
   
PetscScalar C01_{{ field.name }}_{{k}}[{{ field.ndofs }}][{{ npts_z }}][{{field.nbasis_x[k] }}][{{ field.nbasis_y[k] }}] = { { { {  0.,},},},};
PetscScalar C02_{{ field.name }}_{{k}}[{{ field.ndofs }}][{{ npts_y }}][{{ npts_z }}][{{ field.nbasis_x[k] }}] = { { { {  0.,},},},};
PetscScalar C0_{{  field.name }}_{{k}}[{{ field.ndofs }}][{{ npts_x }}][{{ npts_y }}][{{ npts_z }}] = { { { {  0.,},},},};
PetscScalar D01_{{ field.name }}_{{k}}[3][{{ field.ndofs }}][{{ npts_z }}][{{field.nbasis_x[k] }}][{{ field.nbasis_y[k] }}] = { { { { {  0.,},},},},};
PetscScalar D02_{{ field.name }}_{{k}}[3][{{ field.ndofs }}][{{ npts_y }}][{{ npts_z }}][{{ field.nbasis_x[k] }}] = { { { { {  0.,},},},},};
PetscScalar D0_{{  field.name }}_{{k}}[3][{{ field.ndofs }}][{{ npts_x }}][{{ npts_y }}][{{ npts_z }}] = { { { { {  0.,},},},},};
 {% if ndim == 1 %}
  PetscScalar **data_{{field.name}}_{{k}};
      {% endif %}
 {% if ndim == 2 %}
  PetscScalar ***data_{{field.name}}_{{k}};
      {% endif %}
 {% if ndim == 3 %}
  PetscScalar ****data_{{field.name}}_{{k}};
      {% endif %}
    {% endfor %}
  {% endfor %}
 
 {% for field in fieldlist %}
      {% for k in range(field.ncomp) %}
  ierr = DMDAVecGetArrayDOFRead(da_{{field.name}}_{{k}},{{field.name}}_{{k}},&data_{{field.name}}_{{k}});CHKERRQ(ierr);
      {% endfor %}
  {% endfor %}

	//get DMDA ranges
  ierr = DMDAGetCorners(da,&xs,&ys,&zs,&xm,&ym,&zm);CHKERRQ(ierr);
   ierr = DMDAGetInfo(da,0,&xmax,&ymax,&zmax,0,0,0,0,0,0,0,0,0);CHKERRQ(ierr);

//create vals pointer for evaluate
#define quadss [qz + {{ npts_z }} * (qy + {{ npts_y }} * qx)]
#define quadsv(s1) [s1 + {{ ndim }} * (qz + {{ npts_z }} * (qy + {{ npts_y }} * qx))]
#define quadst(s1,s2) [s2 + {{ ndim }} * (s1 + {{ ndim }} * (qz + {{ npts_z }} * (qy + {{ npts_y }} * qx)))]

 {% if ndim == 1 %}
 #define SCALARINDICES [i] quadss
 #define VECTORINDICES(s1) [i] quadsv(s1)
 #define TENSORINDICES(s1,s2) [i] quadst(s2,s1)
  PetscScalar **data_vals;
       {% endif %}
 {% if ndim == 2 %}
 #define SCALARINDICES [j][i] quadss
 #define VECTORINDICES(s1) [j][i] quadsv(s1)
 #define TENSORINDICES(s1,s2) [j][i] quadst(s2,s1)
   PetscScalar ***data_vals;
       {% endif %}
 {% if ndim == 3 %}
 #define SCALARINDICES [k][j][i] quadss
 #define VECTORINDICES(s1) [k][j][i] quadsv(s1)
 #define TENSORINDICES(s1,s2) [k][j][i] quadst(s2,s1)
   PetscScalar ****data_vals;
       {% endif %}
       
ierr = DMDAVecGetArrayDOF(da_vals , evals , &data_vals );CHKERRQ(ierr);
{% if valstype == 'scalar' %}
 #define PVALS data_vals SCALARINDICES
{% elif valstype == 'vector' %}
 #define PVALS data_vals VECTORINDICES(s)
{% elif valstype == 'tensor' %}
 #define PVALS data_vals TENSORINDICES(s1,s2)
{% endif %}


 {% from 'setblocks.template' import SET_PERIODIC_FIELDS with context %}
 {% from 'setblocks.template' import SET_NONPERIODIC_X_FIELDS with context %}
 {% from 'setblocks.template' import SET_NONPERIODIC_Y_FIELDS with context %}
 {% from 'setblocks.template' import SET_NONPERIODIC_Z_FIELDS with context %}
 
{{ SET_PERIODIC_FIELDS() }}
for (k=zs; k<zs+zm; k++) {
{{ SET_NONPERIODIC_Z_FIELDS() }}
   for (j=ys; j<ys+ym; j++) {
     {{ SET_NONPERIODIC_Y_FIELDS() }}
      for (i=xs; i<xs+xm; i++) {
	      {{ SET_NONPERIODIC_X_FIELDS() }}
    
		//compute eval
{% if evaltype == 'h1' %}
{{ h1_eval(evalfield) }}
{% elif evaltype == 'l2' %}
{{ l2_eval(evalfield,fieldlist[0]) }}
{% elif evaltype == 'hdiv' %}
{{ hdiv_eval(evalfield,fieldlist[0]) }}
{% elif evaltype == 'hcurl' %}
{{ hcurl_eval(evalfield,fieldlist[0]) }}
{% endif %}

       }}}

//restore fields arrays and data
 {% for field in fieldlist %}
      {% for k in range(field.ncomp) %}
    ierr = DMDAVecRestoreArrayDOFRead(da_{{field.name}}_{{k}},{{field.name}}_{{k}},&data_{{field.name}}_{{k}});CHKERRQ(ierr);
      {% endfor %}
   {% endfor %}
  
//restore evaluate pointer
ierr = DMDAVecRestoreArrayDOF(da_vals , evals , &data_vals );CHKERRQ(ierr);

  PetscFunctionReturn(0);
}
