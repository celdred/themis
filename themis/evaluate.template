

{# ********************************************* #}

{%macro CLEAR_FIELD(field,k) -%}
{%set ab = a~'_'~b %}
ierr = PetscMemzero({{ 'C01_'~field.name~'_'~k }},sizeof(PetscScalar[{{field.ndofs}}][{{ npts_z }}][{{field.nbasis_x[k] }}][{{ field.nbasis_y[k] }}]));CHKERRQ(ierr);
ierr = PetscMemzero({{ 'C02_'~field.name~'_'~k }},sizeof(PetscScalar[{{field.ndofs}}][{{ npts_y }}][{{ npts_z }}][{{ field.nbasis_x[k] }}]));CHKERRQ(ierr);
ierr = PetscMemzero({{ 'C0_'~field.name~'_'~k }},sizeof(PetscScalar[{{field.ndofs}}][{{ npts_x }}][{{ npts_y }}][{{ npts_z }}]));CHKERRQ(ierr);
{% endmacro %}

{# ********************************************* #}

{%macro EXTRACT_FIELD(field,k) -%}
#define kk (k*{{field.name}}_{{k}}_offset_mult_z[lz] + {{field.name}}_{{k}}_offsets_z[lz]) 
#define jj (j*{{field.name}}_{{k}}_offset_mult_y[ly] + {{field.name}}_{{k}}_offsets_y[ly]) 
#define ii (i*{{field.name}}_{{k}}_offset_mult_x[lx] + {{field.name}}_{{k}}_offsets_x[lx]) 

for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (ly=0;ly<{{ field.nbasis_y[k] }};ly++){
for (lz=0;lz<{{ field.nbasis_z[k] }};lz++){
for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (d=0;d<{{ field.ndofs }};d++){
{% if ndim == 3 %}
C01_{{ field.name }}_{{k}}[d][qz][lx][ly] += data_{{field.name}}_{{k}}[kk][jj][ii][d] * {{field.name}}_{{k}}_basis_z[qz][lz];
{% endif %}
{% if ndim == 2 %}
C01_{{ field.name }}_{{k}}[d][qz][lx][ly] += data_{{field.name}}_{{k}}[jj][ii][d] * {{field.name}}_{{k}}_basis_z[qz][lz];
{% endif %}
{% if ndim == 1 %}
C01_{{ field.name }}_{{k}}[d][qz][lx][ly] += data_{{field.name}}_{{k}}[ii][d] * {{field.name}}_{{k}}_basis_z[qz][lz];
{% endif %}
}}}}}

for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (ly=0;ly<{{ field.nbasis_y[k] }};ly++){
for (qy=0;qy<{{ npts_y }};qy++) { //loop over quadrature pts in y
for (d=0;d<{{ field.ndofs }};d++){
C02_{{ field.name }}_{{k}}[d][qy][qz][lx] += C01_{{ field.name }}_{{k}}[d][qz][lx][ly] * {{field.name}}_{{k}}_basis_y[qy][ly];
}}}}}

for (qy=0;qy<{{ npts_y }};qy++) { //loop over quadrature pts in y
for (qz=0;qz<{{ npts_z }};qz++) { //loop over quadrature pts in z
for (lx=0;lx<{{ field.nbasis_x[k] }};lx++){
for (qx=0;qx<{{ npts_x }};qx++) { //loop over quadrature pts in x
for (d=0;d<{{ field.ndofs }};d++){
C0_{{  field.name }}_{{k}}[d][qx][qy][qz] += C02_{{ field.name }}_{{k}}[d][qy][qz][lx] * {{field.name}}_{{k}}_basis_x[qx][lx];
}}}}}

#undef ii
#undef jj
#undef kk
{% endmacro %}

{# ********************************************* #}

{%macro l2_eval(field) -%}
//THIS IS BROKEN AND NEEDS FIXING

//ADD COMPUTE DETJ
CLEAR_C0; {{ CLEAR_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,0) }}
LOOP_QUAD;
for (d=0;d<{{ fieldlist[1].ndofs }};d++){
PVALS = c0_{{ field.name }}_0 / DETJ;
}
END_QUAD;


{% endmacro %}


{# ********************************************* #}
{%macro h1_eval(field) -%}
CLEAR_C0; {{ CLEAR_FIELD(field,0) }}
{{ EXTRACT_FIELD(field,0) }}
LOOP_QUAD;
for (d=0;d<{{ field.ndofs }};d++){
PVALS = c0_{{ field.name }}_0;
}
END_QUAD;
{% endmacro %}

{# ********************************************* #}

{%macro hdiv_eval(field) -%}
//THIS IS BROKEN AND NEEDS FIXING
//ADD COMPUTE DETJ AND COMPUTE J
{% if ndim == 3 %}
{{ CLEAR_FIELD(0,0) }}
{{ CLEAR_FIELD(0,1) }}
{{ CLEAR_FIELD(0,2) }}
{{ EXTRACT_FIELD(0,0,'c0_0_0') }}
{{ EXTRACT_FIELD(0,1,'c0_0_1') }}
{{ EXTRACT_FIELD(0,2,'c0_0_2') }}
LOOP_QUAD
PVALS[0] = (c0_0_0 * J[0][0] + c0_0_1 * J[0][1] + c0_0_2 * J[0][2]) / DETJ;
PVALS[1] = (c0_0_0 * J[1][0] + c0_0_1 * J[1][1] + c0_0_2 * J[1][2]) / DETJ;
PVALS[2] = (c0_0_0 * J[2][0] + c0_0_1 * J[2][1] + c0_0_2 * J[2][2]) / DETJ;
END_QUAD;
{% endif %}
{% if ndim == 2 %}
{{ CLEAR_FIELD(0,0) }}
{{ CLEAR_FIELD(0,1) }}
{{ EXTRACT_FIELD(0,0,'c0_0_0') }}
{{ EXTRACT_FIELD(0,1,'c0_0_1') }}
LOOP_QUAD
PVALS[0] = (c0_0_0 * J[0][0] + c0_0_1 * J[0][1]) / DETJ;
PVALS[1] = (c0_0_0 * J[1][0] + c0_0_1 * J[1][1]) / DETJ;
END_QUAD;
{% endif %}
{% if ndim == 1 %}
{{ CLEAR_FIELD(0,0) }}
{{ EXTRACT_FIELD(0,0,'c0_0_0') }}
LOOP_QUAD
PVALS[0] = c0_0_0 * J[0][0] / DETJ;
END_QUAD;
{% endif %}
{% endmacro %}

{# ********************************************* #}

{%macro hcurl_eval(field) -%}
//THIS IS BROKEN AND NEEDS FIXING
{% if ndim == 3 %}
//ADD COMPUTE JTINV
{{ CLEAR_FIELD(0,0) }}
{{ CLEAR_FIELD(0,1) }}
{{ CLEAR_FIELD(0,2) }}
{{ EXTRACT_FIELD(0,0,'c0_0_0') }}
{{ EXTRACT_FIELD(0,1,'c0_0_1') }}
{{ EXTRACT_FIELD(0,2,'c0_0_2') }}
LOOP_QUAD
PVALS[0] = (c0_0_0 * JTINV[0][0] + c0_0_1 * JTINV[0][1] + c0_0_2 * JTINV[0][2]);
PVALS[1] = (c0_0_0 * JTINV[1][0] + c0_0_1 * JTINV[1][1] + c0_0_2 * JTINV[1][2]);
PVALS[2] = (c0_0_0 * JTINV[2][0] + c0_0_1 * JTINV[2][1] + c0_0_2 * JTINV[2][2]);
END_QUAD;
{% endif %}
{% if ndim == 2 %}
{{ CLEAR_FIELD(0,0) }}
{{ CLEAR_FIELD(0,1) }}
{{ EXTRACT_FIELD(0,0,'c0_0_0') }}
{{ EXTRACT_FIELD(0,1,'c0_0_1') }}
LOOP_QUAD
PVALS[0] = (c0_0_0 * JTINV[0][0] + c0_0_1 * JTINV[0][1]);
PVALS[1] = (c0_0_0 * JTINV[1][0] + c0_0_1 * JTINV[1][1]);
END_QUAD;
{% endif %}
{% if ndim == 1 %}
{{ CLEAR_FIELD(0,0) }}
{{ EXTRACT_FIELD(0,0,'c0_0_0') }}
LOOP_QUAD
PVALS[0] = c0_0_0 * JTINV[0][0];
END_QUAD;
{% endif %}
{% endmacro %}

{# ********************************************* #}






#include <petsc.h>
#include "math.h"
#include <stdio.h>

PetscScalar assemble(DM da {{ valsargs }} {{ fieldargs }} )

{




  PetscErrorCode ierr;
  PetscInt i,j,k; //element loop indices
   PetscInt qx,qy,qz; //quad indices
   PetscInt lx,ly,lz; //basis indices
   PetscInt d,d1,d2; //dof indices
  PetscInt xs,xm,ys,ym,zs,zm;

#define DETJ detJ[qx][qy][qz]
#define DETJINV detJinv[qx][qy][qz]
#define J J[qx][qy][qz]
#define JTINV JTinv[qx][qy][qz]

PetscScalar C0[{{ npts_x }}][{{ npts_y }}][{{ npts_z }}] = { { { 0.,},},};
#define CLEAR_C0 ierr = PetscMemzero(C0,sizeof(PetscScalar[{{ npts_x }}][{{ npts_y }}][{{ npts_z }}]));CHKERRQ(ierr);
#define c0 C0[qx][qy][qz]

#define LOOP_QUAD   for (qx=0;qx<{{ npts_x }};qx++) { \
                    for (qy=0;qy<{{ npts_y }};qy++) { \
                    for (qz=0;qz<{{ npts_z }};qz++) { 
#define END_QUAD }}}
#define LOOP_DOFS 
#define END_DOFS }
						
 {% for field in fieldlist %}
 {% for k in range(field.ncomp) %}
const   PetscInt {{field.name}}_{{k}}_offsets_x[{{ field.nbasis_x[k] }}] = {{ field.offsets_x[k] }};
const   PetscInt {{field.name}}_{{k}}_offsets_y[{{ field.nbasis_y[k] }}] = {{ field.offsets_y[k] }};
const   PetscInt {{field.name}}_{{k}}_offsets_z[{{ field.nbasis_z[k] }}] = {{ field.offsets_z[k] }};
const   PetscInt {{field.name}}_{{k}}_offset_mult_x[{{ field.nbasis_x[k] }}] = {{ field.offset_mult_x[k] }};
const   PetscInt {{field.name}}_{{k}}_offset_mult_y[{{ field.nbasis_y[k] }}] = {{ field.offset_mult_y[k] }};
const   PetscInt {{field.name}}_{{k}}_offset_mult_z[{{ field.nbasis_z[k] }}] = {{ field.offset_mult_z[k] }};

const   PetscScalar {{field.name}}_{{k}}_basis_x[{{ npts_x }}][{{ field.nbasis_x[k] }}] = {{ field.basis_x[k] }};
const   PetscScalar {{field.name}}_{{k}}_basis_y[{{ npts_y }}][{{ field.nbasis_y[k] }}] = {{ field.basis_y[k] }};
const   PetscScalar {{field.name}}_{{k}}_basis_z[{{ npts_z }}][{{ field.nbasis_z[k] }}] = {{ field.basis_z[k] }};
const   PetscScalar {{field.name}}_{{k}}_derivs_x[{{ npts_x }}][{{ field.nbasis_x[k] }}] = {{ field.derivs_x[k] }};
const   PetscScalar {{field.name}}_{{k}}_derivs_y[{{ npts_y }}][{{ field.nbasis_y[k] }}] = {{ field.derivs_y[k] }};
const   PetscScalar {{field.name}}_{{k}}_derivs_z[{{ npts_z }}][{{ field.nbasis_z[k] }}] = {{ field.derivs_z[k] }};
PetscScalar C01_{{ field.name }}_{{k}}[{{ field.ndofs }}][{{ npts_z }}][{{field.nbasis_x[k] }}][{{ field.nbasis_y[k] }}] = { { { {  0.,},},},};
PetscScalar C02_{{ field.name }}_{{k}}[{{ field.ndofs }}][{{ npts_y }}][{{ npts_z }}][{{ field.nbasis_x[k] }}] = { { { {  0.,},},},};
PetscScalar C0_{{  field.name }}_{{k}}[{{ field.ndofs }}][{{ npts_x }}][{{ npts_y }}][{{ npts_z }}] = { { { {  0.,},},},};
#define c0_{{ field.name }}_{{k}} C0_{{  field.name }}_{{k}}[d][qx][qy][qz]
 {% if ndim == 1 %}
  PetscScalar **data_{{field.name}}_{{k}};
      {% endif %}
 {% if ndim == 2 %}
  PetscScalar ***data_{{field.name}}_{{k}};
      {% endif %}
 {% if ndim == 3 %}
  PetscScalar ****data_{{field.name}}_{{k}};
      {% endif %}
    {% endfor %}
  {% endfor %}
 
 {% for field in fieldlist %}
      {% for k in range(field.ncomp) %}
  ierr = DMDAVecGetArrayDOFRead(da_{{field.name}}_{{k}},{{field.name}}_{{k}},&data_{{field.name}}_{{k}});CHKERRQ(ierr);
      {% endfor %}
  {% endfor %}

	//get DMDA ranges
  ierr = DMDAGetCorners(da,&xs,&ys,&zs,&xm,&ym,&zm);CHKERRQ(ierr);

//create vals pointer for evaluate
#define quadss [qz + {{ npts_z }} * (qy + {{ npts_y }} * qx)]
#define quadsv(d1) [d1 + {{ ndim }} * (qz + {{ npts_z }} * (qy + {{ npts_y }} * qx))]
#define quadst(d1,d2) [d2 + {{ ndim }} * (d1 + {{ ndim }} * (qz + {{ npts_z }} * (qy + {{ npts_y }} * qx)))]

 {% if ndim == 1 %}
 #define SCALARINDICES [i] quadss
 #define VECTORINDICES(d1) [i] quadsv(d1)
 #define TENSORINDICES(d1,d2) [i] quadst(d2,d1)
  PetscScalar **data_vals;
       {% endif %}
 {% if ndim == 2 %}
 #define SCALARINDICES [j][i] quadss
 #define VECTORINDICES(d1) [j][i] quadsv(d1)
 #define TENSORINDICES(d1,d2) [j][i] quadst(d2,d1)
   PetscScalar ***data_vals;
       {% endif %}
 {% if ndim == 3 %}
 #define SCALARINDICES [k][j][i] quadss
 #define VECTORINDICES(d1) [k][j][i] quadsv(d1)
 #define TENSORINDICES(d1,d2) [k][j][i] quadst(d2,d1)
   PetscScalar ****data_vals;
       {% endif %}
       
ierr = DMDAVecGetArrayDOF(da_vals , evals , &data_vals );CHKERRQ(ierr);
{% if valstype == 'scalar' %}
 #define PVALS data_vals SCALARINDICES
{% elif valstype == 'vector' %}
 #define PVALS data_vals VECTORINDICES(d)
{% elif valstype == 'tensor' %}
 #define PVALS data_vals TENSORINDICES(d1,d2)
{% endif %}

for (k=zs; k<zs+zm; k++) {
   for (j=ys; j<ys+ym; j++) {
      for (i=xs; i<xs+xm; i++) {
		
		//compute eval
{% if evaltype == 'h1' %}
{{ h1_eval(evalfield) }}
{% elif evaltype == 'l2' %}
{{ l2_eval(evalfield) }}
{% elif evaltype == 'hdiv' %}
{{ hdiv_eval(evalfield) }}
{% elif evaltype == 'hcurl' %}
{{ hcurl_eval(evalfield) }}
{% endif %}

       }}}

//restore fields arrays and data
 {% for field in fieldlist %}
      {% for k in range(field.ncomp) %}
    ierr = DMDAVecRestoreArrayDOFRead(da_{{field.name}}_{{k}},{{field.name}}_{{k}},&data_{{field.name}}_{{k}});CHKERRQ(ierr);
      {% endfor %}
   {% endfor %}
  
//restore evaluate pointer
ierr = DMDAVecRestoreArrayDOF(da_vals , evals , &data_vals );CHKERRQ(ierr);

  PetscFunctionReturn(0);
}
